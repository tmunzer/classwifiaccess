var bCrypt = require('bcrypt');
var file = "./sqlite/local.db";
var sqlite3 = require("sqlite3").verbose();
var fs = require("fs");


var Sqlite = function(){
    var exists = fs.existsSync(file);
    var db = new sqlite3.Database(file);
    this.db = db;
    this.db.serialize(function() {
        if(!exists) {
            db.run("CREATE TABLE API (id integer primary key, " +
                "clientId VARCHAR(30)," +
                "ownerId INTEGER," +
                "vhmId VARCHAR(15), " +
                "vpcUrl VARCHAR(60), "+
                "accessToken VARCHAR(60)," +
                "refreshToken VARCHAR(60)," +
                "expireAt DATETIME)");
            db.run("CREATE TABLE User (id integer primary key, " +
                "firstName VARCHAR(30), " +
                "lastName VARCHAR(30), " +
                "email VARCHAR(60), " +
                "username VARCHAR(60) NOT NULL UNIQUE, " +
                "password VARCHAR(120) NOT NULL, " +
                "userEnable BOOL, " +
                "lastLogin DATETIME, " +
                "language INTEGER, " +
                "userGroup INTEGER NOT NULL)");
            db.run("CREATE TABLE UserGroup (id integer primary key," +
                "groupName VARCHAR(30))");
            db.run("CREATE TABLE Device (id integer primary key," +
                "deviceId VARCHAR(15)," +
                "ownerId INTEGER, " +
                "macAddress VARCHAR(16), " +
                "hostname VARCHAR(60), " +
                "serialId VARCHAR(14), " +
                "model VARCHAR(10), " +
                "ip VARCHAR(12), " +
                "simType VARCHAR(10), " +
                "location VARCHAR(60))");
            db.run("CREATE TABLE Classroom (id integer primary key," +
                "name VARCHAR(30), " +
                "accessPoint INTEGER)");
            db.run("CREATE TABLE UILanguage (id integer primary key," +
                "language VARCHAR(20)," +
                "code VARCHAR(6))");
            db.run("INSERT INTO User VALUES (1, '', '', '', 'admin', '"+createHash("aerohive")+"', 'true', '', '1', 1)");
            db.run("INSERT INTO UserGroup VALUES (1, 'Administrator')");
            db.run("INSERT INTO UserGroup VALUES (2, 'Teacher')");
            db.run("INSERT INTO UILanguage VALUES (1, 'English', 'en')");
            db.run("INSERT INTO UILanguage VALUES (2, 'Francais', 'fr')");
        }
    });
};

Sqlite.prototype.updateDB = function(table, rowId, entries, callback){
    var updateString = "";
    var fieldNumber = 0;
    for (var entry in entries) {
        if (entry == 'password') {
            if (entries[entry] != "") {
                if (fieldNumber != 0) {
                    updateString += ",  ";
                }
                updateString += entry + "='" + createHash(entries[entry]) + "'";
                fieldNumber++;
            }
        } else {
            if (fieldNumber != 0) {
                updateString += ",  ";
            }
            updateString += entry + "='" + entries[entry] + "'";
            fieldNumber++;
        }
    }
    updateString = 'UPDATE ' + table + ' SET ' + updateString + ' WHERE id=' + rowId + ";" ;
    console.log(updateString);
    this.db.run(updateString, function(err){
        if (err){
            return err;
        }
        callback(err);
    })
};

Sqlite.prototype.insertDB = function(table, rows, callback){
    var insertFields = "";
    var insertValues = "";
    var fieldNumber = 0;
    for (var field in rows) {
        if (fieldNumber != 0) {
            insertFields += ",  ";
            insertValues += ",  ";
        }
        if (field == 'password') {
            if (rows[field] != "") {
                insertFields += field;
                insertValues += "'" + createHash(rows[field]) + "'";
                fieldNumber++;
            }
        } else {
            insertFields += field;
            insertValues += '"' + rows[field] + '"';
            fieldNumber++;
        }
    }
    var insertString = 'INSERT INTO ' + table + ' (' + insertFields + ') VALUES (' + insertValues + ");" ;
    console.log(insertString);
    this.db.run(insertString, function(err){
        if (err){
            return err;
        }
        callback(err);
    });
};

Sqlite.prototype.processOptions = function(rOptions){
    var options = rOptions || {};
    var columnsString = "";
    var orderByString = "";
    var optionNumber = 0;
    if (options.hasOwnProperty("columns")){
        optionNumber = 0;
        for (var column in options['columns']){
            if (optionNumber != 0){
                columnsString += ", ";
            }
            columnsString += options['columns'][column];
            optionNumber++;
        }
    } else {
        columnsString = "*";
    }
    if (options.hasOwnProperty("orderBy")){
        orderByString = " ORDER BY " + options['orderBy'];
    } else {
        orderByString = "";
    }
    return { "columns": columnsString, "orderBy": orderByString};
};


Sqlite.prototype.findOne = function(table, fields, options, callback){
    /**
     Find the first row matching the fields
     Table: Table to request
     Fields: object {fieldName: fieldValue}
     Options: object {option: []} with the following options (optionals)
        columns: columns to retrieve
        orderBy: how to sort the result
     */
    var searchString = "";
    var fieldNumber = 0;
    for (var fieldName in fields){
        if (fieldNumber != 0){
            searchString += " AND "
        }
        searchString += fieldName + "='" + fields[fieldName] +"'";
        fieldNumber ++;
    }
    searchString = "(" + searchString + ")";
    var rOptions = this.processOptions(options);
    var selectString = "SELECT " + rOptions.columns + " FROM " + table + " WHERE "+ searchString;
    console.log(selectString);
    this.db.get(selectString, function(err, ret){
        if (err){
            callback(err);
        }
        callback(err, ret);
    });
};

Sqlite.prototype.findById = function(table, rowId, options, callback){
    /**
     Get one row by its ID
     Table: Table to request
     Options: object {option: []} with the following options (optionals)
         columns: columns to retrieve
         orderBy: how to sort the result
     */
    var rOptions = this.processOptions(options);
    this.db.get("SELECT " + rOptions.columns + " FROM " + table + " WHERE id = ?", rowId, function(err, ret){
        if (err){
            throw err;
        }
        callback(err, ret);
    });
};

Sqlite.prototype.getAll = function(table, options, callback){
/**
    Get all the row in the Database
    Table: Table to request
    Options: object {option: []} with the following options (optionals)
        columns: columns to retrieve
        orderBy: how to sort the result
 */
    var rOptions = this.processOptions(options);
    var allString = "SELECT " + rOptions.columns + " FROM " + table + rOptions.orderBy;
    console.log(allString);
    this.db.all(allString, function(err, ret){
        if (err){
            throw err;
        }
        callback(err, ret);
    })
};

Sqlite.prototype.deleteById = function (table, rId, callback){
    this.db.run("DELETE FROM " + table + " WHERE id = "+rId, function(err, ret){
        if (err){
            throw err;
        }
        callback(err, ret);
    });
};

isValidPassword = function(user, password){
    return bCrypt.compareSync(password, user.password);
};

createHash = function(password){
    return bCrypt.hashSync(password, bCrypt.genSaltSync(10), null);
};

module.exports = Sqlite;
module.exports.isValidPassword = isValidPassword;
module.exports.createHash = createHash;
